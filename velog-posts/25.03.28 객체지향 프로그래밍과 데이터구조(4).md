<p>자료구조
프로그래밍에서 데이터를 효율적으로 접근 및 수정을 가능케 하는 자료의 조직, 관리, 저장을 의미
데이터 값의 모임, 또 데이터 간의 관계, 그리고 데이터에 적용할 수 있는 함수나 명령을 의미
자료구조 형태
자료구조 : 자료간 관계가 1대1인 구조 배열, 연결리스트, 스택, 큐, 덱
비선형구조 : 자료간 관계가 1대 다 혹은 다대 다인 구조 트리, 그래프
알고리즘 성능
효율적인 무제해결을 위해선 알고리즘의 성능을 판단할 수 있는 기준이 필요
상황에 따라 적합한 알고리즘을 선택할 수 있도록 하는 기준
알고리즘 평가 기준
컴퓨터에서 알고리즘과 자료구조의 평가는 시간과 공간 두 자원을 얼마나 소모하는지가 효율성의 중점
일반적으로 시간을 위해 공간(메모리 사용 공간)이 희생되는 경우가 많은
시간복잡도 : 알고리즘의 시간적 자원 소모량
공간복잡도 : 알고리즘의 공간적 자원 소모량 // 하드웨어 발전으로 시간복잡도가 좀더 중요시 됨 (메모리의 발전. 무어의법칙)
Big-O 표기법
알고리즘의 복잡도를 나타내는 점근표기법
데이터 증가량에 따른 시간 증가량을 계산
가장 높은 차수의 계수와 나머지 모든 항을제거하고 표기
알고리즘의 대략적인 효율을 파악할 수 있는 수단
수행 시간 분석
알고리즘의 성능은 상황에 따라 수행 시간이 달라짐
수행 시간을 분석하는 경우 평균의 상황과 최악의 상황을 기준으로 평가함
최선의 상황의 경우 알고리즘의 성능을 분석하는 수단으로 적합하지 않음</p>
<p>제네릭 컬렉션
리스트(list)
런타임 중 크기를 확장할 수 있는 배열기반의 자료구조
배열요소의 갯수를 특정할 수 없는 경우 사용이 용이
List list = new List() /  (클래스) 크기가 동적인 배열 / arrayList 오브젝트배열
list.Add() 맨 뒤에 추가 / big-o 0(n)
list.Insert(몇번째, 값넣으면 나머지는 뒤로 밀림)  / big-o 0(n)
list.Remove(값) 같은 값 제거(같은값 2개면 맨처음값 제거, 만약 없다면 안지움) 
list.RemoveAt(위치) 특정 위치에 있는 요소 제거
list[index] = 값 / 리스트는 배열로 구현되어 있기 때문에 인덱스를 통한 접근이 가능 / 0(1)
int index = list.Indexof(값) / 해당 값이 몇번째에 있는지 탐색. 인덱스를 가져옴 못찾으면 -1
bool contain = list.Contains(값) / 찾아서 있으면true, 없으면 false / 0(n)
리스트 시간복잡도
접근 0(1) 탐색0(n) 삽입0(n) 삭제0(n)
리스트 구현
리스트는 배열기반의 자료구조이며, 배열은 크기를 변경할 수 없는 구조
리스트는 동작 중 크기를 확장하기 위해 포험한 데이터보다 더욱 큰 배열을 사용
=&gt;큰 배열을 미리 만들어놓고 일부 영역만 사용 가능하게 해줘 추가하는 것처럼 보임
List는 length를 사용 못함 Count사용 (몇개 사용하고 있는지)
List.Capacity 리스트의 용량 / 미리 용량 선언 가능
리스트 용량
용량을 가득 채운 상황에서 데이터를 추가하는 경우
더큰 용량의 배열을 새로 생성한 뒤 데이터를 복사하여 새로운 배열을 사용
(기존 배열은 GC에 의해 제거)</p>
<p>LinkedList
데이터를 포함하는 노드들을 연결식으로 만든 자료구조
데이터와 다른 데이터 지점의 참조변수를 가진 노드를 기본 단위로 사용
데이터를 노드를 통해 연결식으로 구성하기 때문에 데이터의 추가/삭제에 유용
노드가 메모리에 연속적으로 배치되지 않고 연결 구조로 다른 데이터의 위치를 확인</p>
<p>연결리스트 구현
연결리스트는 노드를 기본 단위로 연결식으로 구현
노드간의 연결 구조에 따라 단방향, 양방향, 원형으로 구분 (c#은 양방향 연결리스트)</p>
<p>연결리스트 특징
연결리스트의 경우 데이터를 연속적으로 배치하는 배열과 다르게 연결식으로 구성
따라서 데이터의 추가/삭제 과정에서 다른 데이터의 위치와 무관하게 진행되므로 수월함
하지만, 데이터의 접근 과정에서 연속적인 데이터 배치가 아니기 때문에 인덱스 사용 불가하여 처음부터 탐색해야함
인덱스가 없어서 LinkedListNode로 노드기준으로 전(previous), 후(next)기준으로 접근하거
처음이나 마지막 기준으로 접근
.Find .Contain노드기준으로 탐색됨
연결 리스트 시간복잡도
접근 0(n) 탐색0(n) 삽입0(1) 삭제0(1) / 캐시적중률 별로?</p>
<p>스택과 큐
Stack(용량)(스택)
선입후출(FIL0), 후입선출(LIF0) 방식의 자료구조 / DFS(stack) , BFS(queue)
가장 최신 입력된 순서대로 처리해야 하는 상황에 사용
stack.Push(값); // 추가 0(1)
stack.Peek() // 값을 꺼내 확인만 함 // 0(1)
stack.Pop() // 값을 꺼내고 스택에서 제거 // 0(1)
stack.Count // 스택에 몇개있는지 확인
stack.TryPop/TryPeek(out ~) =&gt; 성공하면 꺼내고 아니면 0
ex) undo, UI
큐Queue
FiFO구조 선입선출 LILO 후입후출
queue.Enqueue(값); // 추가
queue.Dequeue(값); // 꺼내기
queue.Peek(값); // 꺼내지 않고 보기
ex) 대기열</p>